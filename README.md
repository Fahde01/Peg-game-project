This C++ program implements a triangular peg solitaire game where a player eliminates pegs by jumping over them with other pegs following specific diagonal and horizontal movement rules, with the objective of removing all pegs until only one remains on the board. The game board is represented using fifteen individual global character variables named pegA through pegO arranged in a triangular formation with five rows (row 1 has one peg at position A, row 2 has two pegs at positions B-C, row 3 has three pegs at positions D-F, row 4 has four pegs at positions G-J, and row 5 has five pegs at positions K-O), where each variable stores either 'T' to represent an occupied position with a peg present or a dot character to represent an empty space, with pegA initialized as empty and all others starting as occupied. The displayBoard function renders the triangular game board visually by printing each peg character with appropriate spacing to create the triangular shape, displaying the peg letters as reference labels on the right side of each row to help players identify positions for their moves. The pegMove function executes a valid move by accepting a three-character string where the first character represents the starting position, the second represents the middle position being jumped over, and the third represents the destination position, then uses an extensive series of conditional statements to handle all possible valid moves on the triangular board (totaling 36 different move combinations), with each condition checking the specific from-to pair and updating three peg variables by setting the starting position and jumped position to dots (removing those pegs) and setting the destination position to 'T' (placing a peg there). The isValidMove function performs comprehensive move validation through multiple stages: first checking if all three positions fall within the valid A-O range, explicitly rejecting two specific invalid diagonal moves from K that would otherwise pass geometric validation, then using three separate chains of if-else statements to retrieve the current state of the three positions involved in the move by mapping each letter to its corresponding global peg variable, verifying that the starting position contains a peg, the middle position contains a peg to jump over, and the destination is empty, then calling helper functions row and col to convert peg letters into numeric row and column coordinates, and finally validating the geometric relationship by checking that the jumped position is exactly midway between the start and destination both horizontally and vertically using the formula that the jump position equals the average of start and destination positions, and confirming that the distances are equal in both directions by comparing the row differences (rowFrom minus rowJump equals rowJump minus rowTo) and column differences (colFrom minus colJump equals colJump minus colTo) to ensure the move follows a straight diagonal or horizontal line. The checkWin function determines victory by counting how many pegs remain on the board through fifteen separate conditional statements that increment a counter for each position containing 'T', then returning true only if exactly one peg remains and false otherwise. The row helper function converts a peg letter into its row number by using a series of range comparisons (pegs K-O return 5, G-J return 4, D-F return 3, B-C return 2, and A returns 1) with an error message and negative one return for invalid inputs, while the col helper function calculates the column position within each row by determining which row the peg belongs to using similar range checks, then subtracting the first letter of that row and adding one to get the relative column position (for example, in row 5, peg K minus K plus one equals column 1, peg L minus K plus one equals column 2, continuing through peg O minus K plus one equals column 5). The main function orchestrates the game flow by first displaying the initial board configuration, then entering an infinite while loop that prompts the user to enter a three-character move string or 'Q' to quit, immediately breaking the loop if the user enters Q, otherwise calling isValidMove to validate the input, executing the move through pegMove if valid, checking for a win condition using checkWin and displaying a congratulatory message before breaking if the player has won, redisplaying the board after each successful move to show the updated game state, and printing an error message followed by the current board state when the user enters an invalid move to help them understand what went wrong and try again. Throughout the implementation, the program demonstrates a procedural programming approach using global variables for game state management rather than object-oriented design, extensive use of conditional logic with long chains of if-else statements to handle the discrete mapping between peg letters and their states or coordinates, helper functions that encapsulate the coordinate system logic to convert between letter-based positions and numeric row-column pairs, geometric validation algorithms that verify moves follow valid paths by checking midpoint relationships and equal spacing, input validation at multiple levels including range checking and state verification, and a simple game loop structure that continues until the player either wins by reducing to one peg, quits voluntarily, or gets stuck with no valid moves remaining, ultimately creating a playable text-based version of the classic triangular peg solitaire puzzle that challenges players to plan strategic jump sequences to eliminate pegs while maintaining move validity according to the game's geometric constraints.
